% Validation de http://cregut.svn.enseeiht.fr/2020/1sn/pim/tps/arhayout/tp10
% Run on 2021-01-20 22:57:06.794816


################################################################################
# Modification des fichiers fournis
################################################################################


================================================================================
## Fichiers qui NE devaient PAS être modifiés
================================================================================

* Fichier alea.adb non modifié... ok
* Fichier alea.ads non modifié... ok
* Fichier exemple_alea.adb non modifié... ok
* Fichier exemple_unbounded_string.adb non modifié... ok
* Fichier sda_exceptions.ads non modifié... ok
* Fichier test_lca.adb non modifié... ok

================================================================================
## Fichiers qui DEVAIENT être modifiés
================================================================================

* Fichier lca_sujet.adb modifié... ok
* Fichier evaluer_alea_lca.adb modifié... ok
* Fichier lca.ads modifié... ok
* Fichier lca.adb modifié... ok
* Fichier th_sujet.adb modifié... ok
* Fichier test_th.adb modifié... ok
* Fichier evaluer_alea_th.adb modifié... ok
* Fichier th.ads modifié... ok
* Fichier th.adb modifié... ok


################################################################################
# Nettoyer
################################################################################

* Running gnatclean... ok


################################################################################
# Exercice 1
################################################################################


================================================================================
## Modifications de lca.ads
================================================================================

* Comparaison de lca.ads et fournis/lca.ads... différents

   |                         and then (La_Donnee (Sda, Cle) = Donnee);                       -- donnée  |                          and then (La_Donnee (Sda, Cle) = Donnee)                        -- donnée 
   |                         -- and then (if Cle_Presente (Sda, Cle)'Old then Taille (Sda) = Taille (Sd |                          -- and then (if Cle_Presente (Sda, Cle)'Old then Taille (Sda) = Taille (Sd
   |                                                                                                    >                          ;
   |    type t_cellule;                                                                                 <
   |    type T_LCA is access t_cellule;                                                                 <
   |    type t_cellule is record                                                                        <
   |       cle:T_Cle;                                                                                   <
   |       donnee:T_Donnee;                                                                             <
   |       suivant:T_LCA;                                                                               <
   |    end record;                                                                                     <
   |                                                                                                    <
   |                                                                                                    >          -- TODO : à compléter


================================================================================
## Exécution de lca_sujet.adb
================================================================================

* Compilation de lca_sujet.adb... ok

  | lca_sujet.adb:4:06: warning: no entities of "SDA_Exceptions" are referenced
  | lca_sujet.adb:4:33: warning: use clause for package "SDA_Exceptions" has no effect
  | lca.adb:1:09: warning: no entities of "Ada.Text_IO" are referenced
  | lca.adb:1:30: warning: use clause for package "Text_IO" has no effect
  | lca.adb:6:19: warning: procedure "Free" is not referenced
  | lca.ads:1:06: warning: no entities of "SDA_Exceptions" are referenced in spec
  | lca.ads:1:06: warning: with clause might be moved to body

* ./lca_sujet... ok
* valgrind ./lca_sujet... ERREUR

  ! ==553697== Memcheck, a memory error detector
  ! ==553697== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
  ! ==553697== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
  ! ==553697== Command: ./lca_sujet
  ! ==553697== 
  ! ==553697== 
  ! ==553697== HEAP SUMMARY:
  ! ==553697==     in use at exit: 160 bytes in 4 blocks
  ! ==553697==   total heap usage: 4 allocs, 0 frees, 160 bytes allocated
  ! ==553697== 
  ! ==553697== 160 (48 direct, 112 indirect) bytes in 1 blocks are definitely lost in loss record 4 of 4
  ! ==553697==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
  ! ==553697==    by 0x4AD654E: __gnat_malloc (in /usr/lib/x86_64-linux-gnu/libgnat-10.so)
  ! ==553697==    by 0x4B03A7C: system__pool_global__allocate (in /usr/lib/x86_64-linux-gnu/libgnat-10.so)
  ! ==553697==    by 0x4B1359E: system__storage_pools__subpools__allocate_any_controlled (in /usr/lib/x86_64-linux-gnu/libgnat-10.so)
  ! ==553697==    by 0x10C3D5: lca_sujet__lca_string_integer__enregistrer__P97b.7 (lca.adb:49)
  ! ==553697==    by 0x10C220: lca_sujet__lca_string_integer__enregistrer.6 (lca.adb:36)
  ! ==553697==    by 0x10BDD5: _ada_lca_sujet (lca_sujet.adb:26)
  ! ==553697==    by 0x10BB6C: main (b~lca_sujet.adb:288)
  ! ==553697== 
  ! ==553697== LEAK SUMMARY:
  ! ==553697==    definitely lost: 48 bytes in 1 blocks
  ! ==553697==    indirectly lost: 112 bytes in 3 blocks
  ! ==553697==      possibly lost: 0 bytes in 0 blocks
  ! ==553697==    still reachable: 0 bytes in 0 blocks
  ! ==553697==         suppressed: 0 bytes in 0 blocks
  ! ==553697== 
  ! ==553697== For lists of detected and suppressed errors, rerun with: -s
  ! ==553697== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)


================================================================================
## Exécution de test_lca.adb
================================================================================

* Compilation de test_lca.adb... ok

  | test_lca.adb:256:17: warning: variable "Inutile" is assigned but never read
  | test_lca.adb:279:35: warning: formal parameter "Cle" is not referenced

* ./test_lca... ERREUR

  ! raised STORAGE_ERROR : stack overflow or erroneous memory access

* Exécution avec valgrind... NON LANCÉE (car erreur sans valgrind)... 


################################################################################
# Exercice 2
################################################################################


================================================================================
## Différences entre lca.ads et th.ads
================================================================================

* Comparaison de lca.ads et th.ads... différents

   |                                                                                                    >  with LCA;
   |                                                                                                    |     Capacite :Integer;
   | package LCA is                                                                                     |     with function fonction_Hachage (
   |                                                                                                    >           Cle : in  T_Cle )
   |                                                                                                    >       return Integer;
   |                                                                                                    >  package TH is
   |                                                                                                    >  Package T_lca_private is
   |                                                                                                    >          new lca(T_Cle =>T_cle, T_Donnee =>T_Donnee );
   |                                                                                                    >  use T_lca_private;
   |         procedure Initialiser(Sda: out T_LCA) with                                                 |          procedure Initialiser_th(Sda: out T_TH) with  
   |                 Post => Est_Vide (Sda);                                                            |                  Post => Est_Vide_th (Sda);
   |         function Est_Vide (Sda : T_LCA) return Boolean;                                            |          function Est_Vide_th (Sda : T_TH) return Boolean;  
   |         function Taille (Sda : in T_LCA) return Integer with                                       |          function Taille_th (Sda : in T_TH) return Integer with  
   |                 Post => Taille'Result >= 0                                                         |                  Post => Taille_th'Result >= 0
   |                         and (Taille'Result = 0) = Est_Vide (Sda);                                  |                          and (Taille_th'Result = 0) = Est_Vide_TH (Sda);  
   |         procedure Enregistrer (Sda : in out T_LCA ; Cle : in T_Cle ; Donnee : in T_Donnee) with    |          procedure Enregistrer_th (Sda : in out T_TH ; Cle : in T_Cle ; Donnee : in T_Donnee) wit  
   |                 Post => Cle_Presente (Sda, Cle)                                                    |                  Post => Cle_Presente_th (Sda, Cle)
   |                         and then (La_Donnee (Sda, Cle) = Donnee);                       -- donnée  |                          and then (La_Donnee_th (Sda, Cle) = Donnee)                     -- donnée 
   |                         -- and then (if Cle_Presente (Sda, Cle)'Old then Taille (Sda) = Taille (Sd |                          -- and then (if Cle_Presente (Sda, Cle)'Old then Taille (Sda) = Taille (Sd
   |                                                                                                    >                          ;
   |         procedure Supprimer (Sda : in out T_LCA ; Cle : in T_Cle) with                             |          procedure Supprimer_TH (Sda : in out T_TH ; Cle : in T_Cle) with    
   |                 Post =>  Taille (Sda) = Taille (Sda)'Old - 1 -- un élément de moins                |                  Post =>  Taille_TH (Sda) = Taille_TH (Sda)'Old - 1 -- un élément de moins    
   |                         and not Cle_Presente (Sda, Cle);         -- la clé a été supprimée         |                          and not Cle_Presente_th (Sda, Cle);         -- la clé a été supprimée
   |         function Cle_Presente (Sda : in T_LCA ; Cle : in T_Cle) return Boolean;                    |          function Cle_Presente_th (Sda : in T_TH ; Cle : in T_Cle) return Boolean;  
   |         function La_Donnee (Sda : in T_LCA ; Cle : in T_Cle) return T_Donnee;                      |          function La_Donnee_th (Sda : in T_TH ; Cle : in T_Cle) return T_Donnee;  
   |         procedure Vider (Sda : in out T_LCA) with                                                  |          procedure Vider_th (Sda : in out T_TH) with  
   |                 Post => Est_Vide (Sda);                                                            |                  Post => Est_Vide_th (Sda);
   |         procedure Pour_Chaque (Sda : in T_LCA);                                                    |          procedure Pour_Chaque_th (Sda : in T_TH);  
   |    type t_cellule;                                                                                 |  type T_Tab_Elements is array (1..Capacite) of T_lca_private.T_LCA;
   |    type T_LCA is access t_cellule;                                                                 |  type T_TH is  
   |    type t_cellule is record                                                                        |          record
   |       cle:T_Cle;                                                                                   |              Elements : T_Tab_Elements;
   |       donnee:T_Donnee;                                                                             <
   |       suivant:T_LCA;                                                                               <
   | end LCA;                                                                                           |  end TH;


================================================================================
## Différences entre test_lca.ads et test_th.ads
================================================================================

* Comparaison de test_lca.adb et test_th.adb... différents

   | with LCA;                                                                                          |  with TH;
   | procedure Test_LCA is                                                                              |  procedure test_th is
   |                                                                                                    |          Function Hachage_nbr_cle(Cle: Unbounded_String) return Integer is
   |         package LCA_String_Integer is                                                              |          begin
   |                 new LCA (T_Cle => Unbounded_String, T_Donnee => Integer);                          |          return length(cle);
   |         use LCA_String_Integer;                                                                    |          end Hachage_nbr_cle;
   |         -- Retourner une chaîne avec des guillemets autour de S                                    |          package Th_string_integer is new TH(T_Cle=>Unbounded_String,T_donnee=>Integer,fonction_Hac
   |                                                                                                    >          use Th_string_integer;
   |                 new Pour_Chaque (Afficher);                                                        |                  new Pour_Chaque_TH (Afficher);  
   |         procedure Construire_Exemple_Sujet (Annuaire : out T_LCA; Bavard: Boolean := False) is     |          procedure Construire_Exemple_Sujet (Annuaire : out T_th; Bavard: Boolean := False) is
   |                 Initialiser (Annuaire);                                                            |                  Initialiser_th (Annuaire);
   |                 pragma Assert (Est_Vide (Annuaire));                                               |                  pragma Assert (Est_Vide_th (Annuaire));
   |                 pragma Assert (Taille (Annuaire) = 0);                                             |                  pragma Assert (Taille_th(Annuaire) = 0);
   |                         Enregistrer (Annuaire, Cles (I), Donnees (I));                             |                          Enregistrer_TH(Annuaire, Cles (I), Donnees (I));  
   |                         pragma Assert (not Est_Vide (Annuaire));                                   |                          pragma Assert (not Est_Vide_th (Annuaire));
   |                         pragma Assert (Taille (Annuaire) = I);                                     |                          pragma Assert (Taille_th (Annuaire) = I);
   |                                 pragma Assert (La_Donnee (Annuaire, Cles (J)) = Donnees (J));      |                                  pragma Assert (La_Donnee_th (Annuaire, Cles (J)) = Donnees (J));
   |                                 pragma Assert (not Cle_Presente (Annuaire, Cles (J)));             |                                  pragma Assert (not Cle_Presente_th (Annuaire, Cles (J)));
   |                 Vider (Annuaire);                                                                  |                  Vider_TH (Annuaire);  
   |                         Supprimer (Annuaire, Cles (I));                                            |                          Supprimer_TH (Annuaire, Cles (I));  
   |                                 pragma Assert (Cle_Presente (Annuaire, Cles (J)));                 |                                  pragma Assert (Cle_Presente_th (Annuaire, Cles (J)));
   |                                 pragma Assert (La_Donnee (Annuaire, Cles (J)) = Donnees (J));      |                                  pragma Assert (La_Donnee_th (Annuaire, Cles (J)) = Donnees (J));
   |                                 pragma Assert (not Cle_Presente (Annuaire, Cles (J)));             |                                  pragma Assert (not Cle_Presente_th (Annuaire, Cles (J)));
   |                 Vider (Annuaire);                                                                  |                  Vider_TH (Annuaire);  
   |                         Supprimer (Annuaire, Cles (I));                                            |                          Supprimer_TH (Annuaire, Cles (I));  
   |                                 pragma Assert (not Cle_Presente (Annuaire, Cles (J)));             |                                  pragma Assert (not Cle_Presente_th (Annuaire, Cles (J)));
   |                                 pragma Assert (Cle_Presente (Annuaire, Cles (J)));                 |                                  pragma Assert (Cle_Presente_th (Annuaire, Cles (J)));
   |                                 pragma Assert (La_Donnee (Annuaire, Cles (J)) = Donnees (J));      |                                  pragma Assert (La_Donnee_th (Annuaire, Cles (J)) = Donnees (J));
   |                 Vider (Annuaire);                                                                  |                  Vider_TH (Annuaire);  
   |                         Supprimer (Annuaire, Cles (Indice));                                       |                          Supprimer_TH (Annuaire, Cles (Indice));  
   |                                         pragma Assert (not Cle_Presente (Annuaire, Cles (J)));     |                                          pragma Assert (not Cle_Presente_th (Annuaire, Cles (J)));
   |                                         pragma Assert (Cle_Presente (Annuaire, Cles (J)));         |                                          pragma Assert (Cle_Presente_th(Annuaire, Cles (J)));
   |                         Vider (Annuaire);                                                          |                          Vider_TH (Annuaire);  
   |                         enregistrer (Annuaire, Cles (Indice), Nouveau);                            |                          enregistrer_TH (Annuaire, Cles (Indice), Nouveau);  
   |                                 pragma Assert (Cle_Presente (Annuaire, Cles (J)));                 |                                  pragma Assert (Cle_Presente_th (Annuaire, Cles (J)));
   |                                         pragma Assert (La_Donnee (Annuaire, Cles (J)) = Nouveau);  |                                          pragma Assert (La_Donnee_th(Annuaire, Cles (J)) = Nouveau)
   |                                         pragma Assert (La_Donnee (Annuaire, Cles (J)) = Donnees (J |                                          pragma Assert (La_Donnee_th (Annuaire, Cles (J)) = Donnees
   |                         Vider (Annuaire);                                                          |                          Vider_TH (Annuaire);  
   |                         Supprimer (Annuaire, Inconnu);                                             |                          Supprimer_th (Annuaire, Inconnu);
   |                 Vider (Annuaire);                                                                  |                  Vider_TH (Annuaire);  
   |                         Inutile := La_Donnee (Annuaire, Inconnu);                                  |                          Inutile := La_Donnee_th (Annuaire, Inconnu);
   |                 Vider (Annuaire);                                                                  |                  Vider_TH (Annuaire);  
   |                         new Pour_Chaque (Sommer);                                                  |                          new Pour_Chaque_TH (Sommer);  
   |                 Vider(Annuaire);                                                                   |                  Vider_TH(Annuaire);  
   |                         new Pour_Chaque (Sommer_Cle_Commence_Par_Q);                               |                          new Pour_Chaque_TH (Sommer_Cle_Commence_Par_Q);  
   |                 Vider(Annuaire);                                                                   |                  Vider_TH(Annuaire);  
   |                         new Pour_Chaque (Sommer_Len4_Erreur);                                      |                          new Pour_Chaque_TH (Sommer_Len4_Erreur);  
   |                 Vider(Annuaire);                                                                   |                  Vider_TH(Annuaire);  
   | end Test_LCA;                                                                                      |  end test_th;


================================================================================
## Exécution de th_sujet.adb
================================================================================

* Compilation de th_sujet.adb... ok

  | th_sujet.adb:4:06: warning: no entities of "SDA_Exceptions" are referenced
  | th_sujet.adb:4:33: warning: use clause for package "SDA_Exceptions" has no effect
  | th.adb:1:09: warning: no entities of "Ada.Text_IO" are referenced
  | th.adb:1:30: warning: use clause for package "Text_IO" has no effect
  | th.adb:2:06: warning: redundant with clause in body
  | th.adb:2:06: warning: no entities of "SDA_Exceptions" are referenced
  | th.adb:2:30: warning: "SDA_Exceptions" is already use-visible through previous use_clause at th.ads:1
  | th.adb:2:30: warning: use clause for package "SDA_Exceptions" has no effect
  | th.adb:3:06: warning: redundant with clause in body
  | th.ads:1:06: warning: no entities of "SDA_Exceptions" are referenced
  | th.ads:1:22: warning: use clause for package "SDA_Exceptions" has no effect

* ./th_sujet... ok
* valgrind ./th_sujet... ERREUR

  ! ==553729== Memcheck, a memory error detector
  ! ==553729== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
  ! ==553729== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
  ! ==553729== Command: ./th_sujet
  ! ==553729== 
  ! ==553729== 
  ! ==553729== HEAP SUMMARY:
  ! ==553729==     in use at exit: 640 bytes in 14 blocks
  ! ==553729==   total heap usage: 14 allocs, 0 frees, 640 bytes allocated
  ! ==553729== 
  ! ==553729== 640 (48 direct, 592 indirect) bytes in 1 blocks are definitely lost in loss record 14 of 14
  ! ==553729==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
  ! ==553729==    by 0x4AD654E: __gnat_malloc (in /usr/lib/x86_64-linux-gnu/libgnat-10.so)
  ! ==553729==    by 0x4B03A7C: system__pool_global__allocate (in /usr/lib/x86_64-linux-gnu/libgnat-10.so)
  ! ==553729==    by 0x4B1359E: system__storage_pools__subpools__allocate_any_controlled (in /usr/lib/x86_64-linux-gnu/libgnat-10.so)
  ! ==553729==    by 0x10DCA0: th_sujet__th_string_integer__t_lca_private__enregistrer__P229b.21 (lca.adb:49)
  ! ==553729==    by 0x10DAE6: th_sujet__th_string_integer__t_lca_private__enregistrer.20 (lca.adb:36)
  ! ==553729==    by 0x10E0F8: th_sujet__th_string_integer__enregistrer_th.16 (th.adb:44)
  ! ==553729==    by 0x10CE1C: _ada_th_sujet (th_sujet.adb:31)
  ! ==553729==    by 0x10CB8C: main (b~th_sujet.adb:290)
  ! ==553729== 
  ! ==553729== LEAK SUMMARY:
  ! ==553729==    definitely lost: 48 bytes in 1 blocks
  ! ==553729==    indirectly lost: 592 bytes in 13 blocks
  ! ==553729==      possibly lost: 0 bytes in 0 blocks
  ! ==553729==    still reachable: 0 bytes in 0 blocks
  ! ==553729==         suppressed: 0 bytes in 0 blocks
  ! ==553729== 
  ! ==553729== For lists of detected and suppressed errors, rerun with: -s
  ! ==553729== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)


================================================================================
## Exécution de test_th.adb
================================================================================

* Compilation de test_th.adb... ok

  | test_th.adb:256:17: warning: variable "Inutile" is assigned but never read
  | test_th.adb:279:35: warning: formal parameter "Cle" is not referenced

* ./test_th... ERREUR

  ! raised STORAGE_ERROR : stack overflow or erroneous memory access

* Exécution avec valgrind... NON LANCÉE (car erreur sans valgrind)... 


################################################################################
# Exercice 3
################################################################################


================================================================================
## Différences entre evaluer_alea_lca.ads et evaluer_alea_th.ads
================================================================================

* Comparaison de evaluer_alea_lca.adb et evaluer_alea_th.adb... différents

   | with LCA;                                                                                          |  with TH;
   |                                                                                                    <
   |                 package Lca_integer_integer is                                                     |                  function Hachage_identite(Cle: Integer) return Integer is
   |                    new LCA(Integer, Integer);                                                      |                  begin
   |                 use Lca_integer_integer;                                                           |                       return Cle;
   |                 Lca: T_LCA;                                                                        |                  end Hachage_identite;
   |                                                                                                    >
   |                                                                                                    >                  package th_integer is
   |                                                                                                    >                        new TH(T_Cle=>integer,T_Donnee=>integer,Capacite=>taille,fonction_hachage=>H
   |                                                                                                    >                  use th_integer;
   |                                                                                                    >
   |                                                                                                    >                   Th:T_TH;  
   |                                                                                                    >
   |            Initialiser(Lca);--initialiser les fréquences                                           |                        Initialiser_th(Th);
   |                                                                                                    <
   |                                                                                                    >                            -- Initialise les fréquences
   |                Enregistrer(Lca, i, 0);                                                             |                                    Enregistrer_th(Th, i, 0);
   |               Enregistrer(Lca, Nombre_alea, La_Donnee(Lca, Nombre_alea) + 1);                      |                                 Enregistrer_th(Th, Nombre_alea, La_Donnee_TH(Th, Nombre_alea) + 1  
   |                                                                                                    |                                 -- Calculer les fréquences
   |            for i in 1..Borne loop                                                                  |                            for I in 1..Borne loop
   |               Freq := La_Donnee(Lca, i);                                                           |                                  Freq := La_Donnee_TH(Th, i);  


================================================================================
## Exécutions de evaluer_alea_*
================================================================================

* Running gnatclean... ok
* Compilation de evaluer_alea_lca.adb... ok

  | lca.adb:1:09: warning: no entities of "Ada.Text_IO" are referenced
  | lca.adb:1:30: warning: use clause for package "Text_IO" has no effect
  | lca.adb:6:19: warning: procedure "Free" is not referenced
  | lca.ads:1:06: warning: no entities of "SDA_Exceptions" are referenced in spec
  | lca.ads:1:06: warning: with clause might be moved to body

* Compilation de evaluer_alea_th.adb... ok

  | th.adb:1:09: warning: no entities of "Ada.Text_IO" are referenced
  | th.adb:1:30: warning: use clause for package "Text_IO" has no effect
  | th.adb:2:06: warning: redundant with clause in body
  | th.adb:2:06: warning: no entities of "SDA_Exceptions" are referenced
  | th.adb:2:30: warning: "SDA_Exceptions" is already use-visible through previous use_clause at th.ads:1
  | th.adb:2:30: warning: use clause for package "SDA_Exceptions" has no effect
  | th.adb:3:06: warning: redundant with clause in body
  | th.ads:1:06: warning: no entities of "SDA_Exceptions" are referenced
  | th.ads:1:22: warning: use clause for package "SDA_Exceptions" has no effect


================================================================================
## Tests nominaux
================================================================================


--------------------------------------------------------------------------------
### Cas : Classique : dé à 6 faces, 100 tirages
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 6 100... ok

  | Borne  : 6
  | Taille : 100
  | Min : 16
  | Max : 22

* valgrind ./evaluer_alea_lca 6 100... ERREUR

  ! ==553783== Memcheck, a memory error detector
  ! ==553783== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
  ! ==553783== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
  ! ==553783== Command: ./evaluer_alea_lca 6 100
  ! ==553783== 
  ! ==553783== 
  ! ==553783== HEAP SUMMARY:
  ! ==553783==     in use at exit: 96 bytes in 6 blocks
  ! ==553783==   total heap usage: 17 allocs, 11 frees, 6,640 bytes allocated
  ! ==553783== 
  ! ==553783== 96 (16 direct, 80 indirect) bytes in 1 blocks are definitely lost in loss record 6 of 6
  ! ==553783==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
  ! ==553783==    by 0x4AD654E: __gnat_malloc (in /usr/lib/x86_64-linux-gnu/libgnat-10.so)
  ! ==553783==    by 0x10C5D4: evaluer_alea_lca__calculer_statistiques__lca_integer_integer__enregistrer.10 (lca.adb:36)
  ! ==553783==    by 0x10C188: evaluer_alea_lca__calculer_statistiques.4 (evaluer_alea_lca.adb:86)
  ! ==553783==    by 0x10BED2: _ada_evaluer_alea_lca (evaluer_alea_lca.adb:123)
  ! ==553783==    by 0x10B9E2: main (b~evaluer_alea_lca.adb:253)
  ! ==553783== 
  ! ==553783== LEAK SUMMARY:
  ! ==553783==    definitely lost: 16 bytes in 1 blocks
  ! ==553783==    indirectly lost: 80 bytes in 5 blocks
  ! ==553783==      possibly lost: 0 bytes in 0 blocks
  ! ==553783==    still reachable: 0 bytes in 0 blocks
  ! ==553783==         suppressed: 0 bytes in 0 blocks
  ! ==553783== 
  ! ==553783== For lists of detected and suppressed errors, rerun with: -s
  ! ==553783== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)

* ./evaluer_alea_th 6 100... ok

  | Borne  : 6
  | Taille : 100
  | Min : 11
  | Max : 24

* valgrind ./evaluer_alea_th 6 100... ERREUR

  ! ==553787== Memcheck, a memory error detector
  ! ==553787== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
  ! ==553787== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
  ! ==553787== Command: ./evaluer_alea_th 6 100
  ! ==553787== 
  ! ==553787== 
  ! ==553787== HEAP SUMMARY:
  ! ==553787==     in use at exit: 96 bytes in 6 blocks
  ! ==553787==   total heap usage: 17 allocs, 11 frees, 6,640 bytes allocated
  ! ==553787== 
  ! ==553787== 96 bytes in 6 blocks are definitely lost in loss record 1 of 1
  ! ==553787==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
  ! ==553787==    by 0x4AD654E: __gnat_malloc (in /usr/lib/x86_64-linux-gnu/libgnat-10.so)
  ! ==553787==    by 0x10C732: evaluer_alea_th__calculer_statistiques__th_integer__t_lca_private__enregistrer.16 (lca.adb:36)
  ! ==553787==    by 0x10CAD6: evaluer_alea_th__calculer_statistiques__th_integer__enregistrer_th.13 (th.adb:44)
  ! ==553787==    by 0x10C2E8: evaluer_alea_th__calculer_statistiques.4 (evaluer_alea_th.adb:91)
  ! ==553787==    by 0x10BEF4: _ada_evaluer_alea_th (evaluer_alea_th.adb:129)
  ! ==553787==    by 0x10BA04: main (b~evaluer_alea_th.adb:255)
  ! ==553787== 
  ! ==553787== LEAK SUMMARY:
  ! ==553787==    definitely lost: 96 bytes in 6 blocks
  ! ==553787==    indirectly lost: 0 bytes in 0 blocks
  ! ==553787==      possibly lost: 0 bytes in 0 blocks
  ! ==553787==    still reachable: 0 bytes in 0 blocks
  ! ==553787==         suppressed: 0 bytes in 0 blocks
  ! ==553787== 
  ! ==553787== For lists of detected and suppressed errors, rerun with: -s
  ! ==553787== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)


--------------------------------------------------------------------------------
### Cas : Beaucoup de doubles
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 5 100... ok

  | Borne  : 5
  | Taille : 100
  | Min : 18
  | Max : 22

* ./evaluer_alea_th 5 100... ok

  | Borne  : 5
  | Taille : 100
  | Min : 19
  | Max : 26


--------------------------------------------------------------------------------
### Cas : Peu de doubles
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 100000 10... ERREUR: Ne se termine pas !
* ./evaluer_alea_th 100000 10... ERREUR: Ne se termine pas !

--------------------------------------------------------------------------------
### Cas : Limite pour Borne et Taille
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 2 2... ok

  | Borne  : 2
  | Taille : 2
  | Min : 0
  | Max : 2

* ./evaluer_alea_th 2 2... ok

  | Borne  : 2
  | Taille : 2
  | Min : 1
  | Max : 1


================================================================================
## Tests de robustesse
================================================================================


--------------------------------------------------------------------------------
### Cas : Deux entiers attendus
--------------------------------------------------------------------------------

* ./evaluer_alea_lca XYZ ZYT... ERREUR

  ! raised CONSTRAINT_ERROR : bad input for 'Value: "XYZ"

* ./evaluer_alea_th XYZ ZYT... ERREUR

  ! raised CONSTRAINT_ERROR : bad input for 'Value: "XYZ"


--------------------------------------------------------------------------------
### Cas : Taille doit être un entier
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 10 ZYT... ERREUR

  ! raised CONSTRAINT_ERROR : bad input for 'Value: "ZYT"

* ./evaluer_alea_th 10 ZYT... ERREUR

  ! raised CONSTRAINT_ERROR : bad input for 'Value: "ZYT"


--------------------------------------------------------------------------------
### Cas : Borne doit être un entier
--------------------------------------------------------------------------------

* ./evaluer_alea_lca XYZ 30... ERREUR

  ! raised CONSTRAINT_ERROR : bad input for 'Value: "XYZ"

* ./evaluer_alea_th XYZ 30... ERREUR

  ! raised CONSTRAINT_ERROR : bad input for 'Value: "XYZ"


--------------------------------------------------------------------------------
### Cas : Borne et Taille doivent être strictement positifs
--------------------------------------------------------------------------------

* ./evaluer_alea_lca -4 -10... ok

  | Borne  : -4
  | Taille : -10
  | Min : -10
  | Max : 0

* ./evaluer_alea_th -4 -10... ok

  | Borne  : -4
  | Taille : -10
  | Min : -10
  | Max : 0


--------------------------------------------------------------------------------
### Cas : Taille doit être strictement positif
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 4 -10... ok

  | Borne  : 4
  | Taille : -10
  | Min : -10
  | Max : 0

* ./evaluer_alea_th 4 -10... ERREUR

  | Borne  : 4
  | Taille : -10


  ! raised CONSTRAINT_ERROR : th.adb:44 index check failed


--------------------------------------------------------------------------------
### Cas : Borne doit être strictement positif
--------------------------------------------------------------------------------

* ./evaluer_alea_lca -4 10... ERREUR

  | Borne  : -4
  | Taille : 10


  ! raised CONSTRAINT_ERROR : a-nudira.adb:54 range check failed

* ./evaluer_alea_th -4 10... ERREUR

  | Borne  : -4
  | Taille : 10


  ! raised CONSTRAINT_ERROR : a-nudira.adb:54 range check failed


--------------------------------------------------------------------------------
### Cas : Il manque la taille (ou la borne)
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 5... ok

  | Usage : ./evaluer_alea_lca Borne Taille
  | 
  |    Borne  : les nombres sont tirés dans l'intervalle 1..Borne
  |    Taille : la taille de l'échantillon

* ./evaluer_alea_th 5... ok

  | Usage : ./evaluer_alea_th Borne Taille
  | 
  |    Borne  : les nombres sont tirés dans l'intervalle 1..Borne
  |    Taille : la taille de l'échantillon


--------------------------------------------------------------------------------
### Cas : Borne doit être un entier ou il manque la taille
--------------------------------------------------------------------------------

* ./evaluer_alea_lca XYZ... ok

  | Usage : ./evaluer_alea_lca Borne Taille
  | 
  |    Borne  : les nombres sont tirés dans l'intervalle 1..Borne
  |    Taille : la taille de l'échantillon

* ./evaluer_alea_th XYZ... ok

  | Usage : ./evaluer_alea_th Borne Taille
  | 
  |    Borne  : les nombres sont tirés dans l'intervalle 1..Borne
  |    Taille : la taille de l'échantillon


--------------------------------------------------------------------------------
### Cas : Taille doit être strictement positif
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 4 0... ok

  | Borne  : 4
  | Taille : 0
  | Min : 0
  | Max : 0

* ./evaluer_alea_th 4 0... ERREUR

  | Borne  : 4
  | Taille : 0


  ! raised CONSTRAINT_ERROR : th.adb:39 divide by zero


--------------------------------------------------------------------------------
### Cas : Borne doit être strictement positif
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 0 100... ERREUR

  | Borne  : 0
  | Taille : 100


  ! raised CONSTRAINT_ERROR : a-nudira.adb:54 range check failed

* ./evaluer_alea_th 0 100... ERREUR

  | Borne  : 0
  | Taille : 100


  ! raised CONSTRAINT_ERROR : a-nudira.adb:54 range check failed


--------------------------------------------------------------------------------
### Cas : Borne = 1 : Ne respecte pas la précondition de Calculer_Statistiques
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 1 100... ok

  | Borne  : 1
  | Taille : 100
  | Min : 100
  | Max : 100

* ./evaluer_alea_th 1 100... ok

  | Borne  : 1
  | Taille : 100
  | Min : 100
  | Max : 100


--------------------------------------------------------------------------------
### Cas : Taille = 1 : Ne respecte pas la précondition de Calculer_Statistiques
--------------------------------------------------------------------------------

* ./evaluer_alea_lca 10 1... ok

  | Borne  : 10
  | Taille : 1
  | Min : 0
  | Max : 1

* ./evaluer_alea_th 10 1... ok

  | Borne  : 10
  | Taille : 1
  | Min : 0
  | Max : 1



################################################################################
# Nettoyer
################################################################################

* Running gnatclean... ok

<!-- vi: set ts=8: -->
